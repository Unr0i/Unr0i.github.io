---
layout:     post
title:      修复内存泄漏
subtitle:   一次修复第三方dll内存泄漏的过程
date:       2023-06-02
author:     LanKai
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Windows DLL 内存泄漏
---

## 前言

   使用某OCR软件时，偶尔循环检测大文件时发现存在严重的内存泄漏，使用腾讯的内存泄漏检测工具，获取了泄漏信息，尝试修复该漏洞，最后成功修复，具有一定的代表性，故梳理记录一下。


## 正文

   整个过程分为定位、修复、验证三部分，根据泄漏信息，定位到漏洞存在于一个名称为KernelAPI.dll的库中，


### 1、定位

#### 腾讯自研的一款运行时C/C++内存泄漏分析工具tMemmoryMonitor，目标进程退出时，没有被释放且没有指针指向的无主内存块即为内存泄漏，利用垃圾回收检测出堆内存中所有没有被引用的内存单元，准确率很高。

#### 输出log
```
 	===========================================================================
  	Leaks, 3 total, size 1332 byte(s) of leak(s)
	Call stack:
		MSVCR100.dll+0x1233b!operator new
		KernelAPI.dll+0x23a0ba!pfsm_clear
		KernelAPI.dll+0x75b55!kRecSetLetters
		KernelAPI.dll+0x3df000!std::_Mutex::_Mutex
		KernelAPI.dll+0x3df0ba!std::_Mutex::_Mutex
		ntdll.dll+0x39264!RtlQueryEnvironmentVariable
		ntdll.dll+0x39a72!RtlAllocateActivationContextStack
		ntdll.dll+0x3975c!RtlDecodePointer
		ntdll.dll+0x39789!LdrInitializeThunk

	Leaks, 3 total, size 108 byte(s) of leak(s)
	Call stack:
		MSVCR100.dll+0x1233b!operator new
		KernelAPI.dll+0x75b3d!kRecSetLetters
		KernelAPI.dll+0x3df000!std::_Mutex::_Mutex
		KernelAPI.dll+0x3df0ba!std::_Mutex::_Mutex
	 	ntdll.dll+0x39264!RtlQueryEnvironmentVariable
		ntdll.dll+0x39a72!RtlAllocateActivationContextStack
		ntdll.dll+0x3975c!RtlDecodePointer
 		ntdll.dll+0x39789!LdrInitializeThunk
				
	Leaks, 1 total, size 40 byte(s) of leak(s)
	Call stack:
		MSVCR100.dll+0x1233b!operator new
		IPP_OmniPage.dll+0x71d1a!SetCommonDLMPtr
		KernelAPI.dll+0x20d293!WesternFontSelector::~WesternFontSelector
		KernelAPI.dll+0x20d3e7!WesternFontSelector::~WesternFontSelector
		KernelAPI.dll+0x1eea32!ImfGetExifInfo
		KernelAPI.dll+0x1ef8b4!ImfGetExifInfo
		KernelAPI.dll+0x1f4059!ImfLoadPage
		KernelAPI.dll+0x1648f0!ImgLoad
		KernelAPI.dll+0x9fb44!kRecLoadImg
		KernelAPI.dll+0x9fe39!kRecLoadImgFU8
		KernelAPI.dll+0x9ffc2!kRecLoadImgFW
		EstOcr.dll+0x27f4!?
		OCRParse.exe+0xc075!?
		OCRParse.exe+0xcc6a!?
		OCRParse.exe+0xc5f8!?
		OCRParse.exe+0xbac3!?
		OCRParse.exe+0x1b81!?
		OCRParse.exe+0x97ff!?
		OCRParse.exe+0xeb138!?
		KERNEL32.dll+0x1344d!BaseThreadInitThunk
	===========================================================================			
	FINAL SUMMARY:
			Leaks	7 total	1480 byte(s) of leak(s)	2120 byte(s) of unfreed
	Details: C:\tMemMonitor\bin\data\OCRParse.exe.2688.log
```

#### 静态分析

```objc
- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;
```


#### 动态调试

- 泄漏的内存分析
<img width="452" alt="image" src="https://github.com/Unr0i/Unr0i.github.io/assets/63570231/23159102-1b3a-4bac-a05a-6ab1c023b7e6">

- 泄漏的产生
<img width="452" alt="image" src="https://github.com/Unr0i/Unr0i.github.io/assets/63570231/71a6a838-bcd8-4ec8-9b18-8ea29d427da8">

- 泄漏的内存地址
<img width="232" alt="image" src="https://github.com/Unr0i/Unr0i.github.io/assets/63570231/beb83e2f-f749-4005-b1a8-8118b86d65d4">


```

```


### 2、修复

首先，我们用`runtime`在添加监听之前和之后分别打印一下类对象

会发现添加监听后的`personModel`的类从 `BYPersonModel` 变成了`NSKVONotifying_BYPersonModel`，也就是`NSKVONotifying_+类名`的形式。
就是说系统为我们自动生创建了一个新的类，然后通过这个类去实现监听方法。

进一步验证，我们自己创建一个`NSKVONotifying_BYPersonModel`类，添加KVO时，会发出警告

```
KVO_demo[19623:258692] BYPersonModel
KVO_demo[19623:258692] [general] KVO failed to allocate class pair for name NSKVONotifying_BYPersonModel, automatic key-value observing will not work for this class
KVO_demo[19623:258692] BYPersonModel
```

并且系统无法自动生成`NSKVONotifying_BYPersonModel`类。

下面我们使用下面打印`NSKVONotifying_BYPersonModel`的属性和方法

观察可以发现 `NSKVONotifying_BYPersonModel` 没有`ivar`。
重写了`setName `、`class `和`dealloc `方法，还新增了一个`_isKVOA`方法
-  `_isKVOA`用来判断是否是系统生成的`KVO`
-  `setName:`重写Set方法，并发送监听
-  `class` 返回父类，隐藏系统生成的 `NSKVONotifying_类`
-  `dealloc`销毁时移除一些方法

#### 我们来看看重写的`set`方法做了什么


#### 尝试手动触发一个KVO

#### 到此整个`KVO`流程基本上就清晰了：

![](https://user-gold-cdn.xitu.io/2018/9/21/165fb89bc6ba9262?w=1878&h=898&f=png&s=150722)





### 3、验证

通过 `KVO` 底层的学习，我们知道了如何动态生成一个自己的类。


